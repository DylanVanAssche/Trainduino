#include <wiring.h>
#include <digitalWriteFast.h>  // Port manipulation library...
#include <digital_write_macros.h> 
#include <SPI.h>  // RF24 libraries
#include "nRF24L01.h"
#include "RF24.h"

/*
   ******************************************
   *               Trainduino               *
   *                                        *
   *-------------> S88-Wireless <-----------*
   *                   BASE                 *
   *                                        *
   *              V 1.0 RELEASE             *
   ******************************************
   THIS IS A RELEASE! I'm never resposibly for any damage to your stuff! This version is tested on Arduino UNO.

   This sketch can simulate up to 10 S88 modules with each 16 feedback pins. That means that you can monitor 160 I/O pins over a wireless connection:)
   It's also heavy documented, so you don't need a lot knowledge to understand it.
   (c) Dylan Van Assche (2013 - 2014), producer of the Trainduino serie.   
*/

#define S88_CLOCK    2  // CLOCK line = HIGH? -> Do something NOW!
#define S88_LOAD     3  // LOAD line = HIGH? -> Master request the data NOW!
#define S88_DATAOUT  4  // DATA line = This line will be used to write out the requested data in sync with the CLOCK pulses when the LOAD line is triggered.
#define S88_RESET    5  // Not necessary since this RESET line only affects the 4044 chips but we want to simulate the 4014 chips.
#define NUMBER_OF_S88MODULES  10  // The number of S88 units we want to simulate with the Arduino.

#define WIRELESS_LED A0  // This LED will go ON if we are doing stuff in the 'Wireless part' and goes OFF if we are done there.
#define S88_LED A1  // This LED will go ON if we are doing stuff in the 'S88 part' and goes OFF if we are done there.

RF24 s88Radio(9,10); // RF24 setup...
const uint64_t pipes[2] = {0xF0F0F0F0E1LL, 0xF0F0F0F0D2LL};
uint16_t s88Data[NUMBER_OF_S88MODULES]; // The s88 16-bit data storage.

volatile boolean LOADTrigger = false;

byte s88[2 * NUMBER_OF_S88MODULES]; // The S88 data that will be received from the slaves. 
byte bitIndex = 0;
byte s88DataIndex = 0;
byte address = 1; // The BASE has address 0 so we will not use that as a SLAVE_ADDRESS.

void setup()
{
  attachInterrupt(0, CLOCK, RISING); // Activate CLOCK interrupt on EVERY rising pulse of the CLOCK line.

  pinModeFast(S88_LOAD, INPUT); // pinModeFast -> pinMode for digitalWriteFast port manipulation library.
  pinModeFast(S88_DATAOUT, OUTPUT);

  s88Radio.begin();
  s88Radio.setRetries(15,15);
  s88Radio.setPayloadSize(8);
  s88Radio.openWritingPipe(pipes[0]);
  s88Radio.openReadingPipe(1,pipes[1]);
  s88Radio.startListening();
}

void loop()
{  
  // Combines 2x 8bit shift registers into 1x 16bit shift register. 
  for(byte dataManipulationIndex = 0;  dataManipulationIndex < NUMBER_OF_S88MODULES; dataManipulationIndex++)
  {
    s88Data[dataManipulationIndex] = (s88[dataManipulationIndex * 2 + 1] << 8)  |  s88[dataManipulationIndex * 2];
  }

  s88Radio.stopListening();

  boolean transmissionComplete = s88Radio.write(&address, sizeof(byte));

  if (transmissionComplete)
  {
    digitalWriteFast(WIRELESS_LED, HIGH);
    address++;
    if(address > 10)
    {
      address = 1; 
    }    
  }

  s88Radio.startListening();

  unsigned long timeOutTime = millis();
  boolean timeOutStatus = false;

  while (!s88Radio.available() && !timeOutStatus)

    if (millis() - timeOutTime > 200 )
    {
      timeOutStatus = true;
    }

  if(!timeOutStatus)  // DATA is valid so we may read it out...
  {
    byte data;
    s88Radio.read(&data, sizeof(byte));
    s88[address - 1] = data;
    digitalWriteFast(WIRELESS_LED, LOW);
  }
}    

void CLOCK() // If CLOCK rises, check the LOAD line to see if we have to do something!
{
  detachInterrupt(0); // Deactivate interrupt CLOCK.
  
  if(digitalReadFast(S88_LOAD) || LOADTrigger != false) // The LOAD line has been triggered by the command station, he wants the data NOW! Let's give it to him.
  {
    LOADTrigger = true; // The LOAD line will not stay high until all the bits are written out, only a pulse occurs every cycle but this function must go on until all the bits are written out.
    digitalWriteFast(S88_LED, HIGH);

    if(s88Data[s88DataIndex] & (1 << bitIndex)) // Write every bit out.
    { 
      digitalWriteFast(S88_DATAOUT, HIGH);
    }
    else
    {
      digitalWriteFast(S88_DATAOUT, LOW);
    }

    bitIndex++; // Next bit
  }

  if(bitIndex > 15) // 16 bits passed? Reset the bitIndex counter...
  {
    s88DataIndex++; // Next 16-bit shift register.
    bitIndex = 0;

    if(s88DataIndex > NUMBER_OF_S88MODULES - 1) // Human counting to array counting conversion. We want to simulate 10 S88 modules, so we give the variable NUMBER_OF_S88MODULES a value of 10. However, the array starts always with a 0.
    {
      s88DataIndex = 0; // Reset the s88DataIndex counter, this counter tracks the number of 16-bit shift register 4014.
      LOADTrigger = false; // Everything is written out so we can stop writing data out.
      digitalWriteFast(S88_LED, LOW);
    }
  } 

  attachInterrupt(0, CLOCK, RISING); // Activate interrupt CLOCK again.
}
